# 分布式

[一文读懂分布式架构知识体系（内含超全核心知识大图）](https://juejin.cn/post/6844903967701336078)

![pic_008](img/分布式和微服务/16dd338cf97efdb7tplv-t2oaga2asx-watermark.awebp)



## 什么是分布式

利用物理架构形成多个自治的处理元素, **不共享主内存**, 但是通过**发送信息**合作. ——Leslie Lamport

- 不共享主内存: 多台独立的机器运作

* 发送消息合作: 机器之间进行通信, 调用服务, 调用接口, 无论是服务还是接口, 无论协议是http还是rpc, 统称为发送消息

---

例子: 单体 -> 集群 -> 分布式

单体: 一台机器做所有的事情. 一个大项目, 大而全, 包括所有的模块, 模块之间直接调用

集群: 同样的单体应用部署到很多的服务器上, 在前面加负载均衡. Client访问的时候访问压力小的机器. 多台机器, 部署同样的应用.

分布式: 术业有专攻: 一台服务器不再提供完整的服务, 拆分成不同的功能, 不同的功能负责自己的业务. 例如需要多个商品目录系统, 其成本比其他模块低, 只需要多加几个商品目录模块, 不需要把整个系统多部署几份. 专业的人做专业的事, 降低成本. 例如: OA: 权限系统, 员工系统, 请假系统(可能5个员工系统, 1个请假系统), 一个请求过来, 系统之间独立并且相互调用

## 分布式的作用

### 为什么需要分布式

实际工作的痛点:

* 单体项目变得臃肿, 复杂度增加. 各种层耦合, 调用冲突. 我改了我的代码, 别人不经意调用了, 我修改了之后, 他也会出错, 或者需要重新测试. 

* 测试上线繁琐
* 开发效率低. 新功能无法摆脱老功能的, 例如升级版本, 换依赖, 升级版本, 升级了别人的代码会报错. 编译启动时间长

---

单体应用的问题:

* 应用代码耦合严重，功能扩展难

* 新需求开发交互周期长，测试工作量大

* 新加入的开发同事需要很长时间才能熟悉系统

* 升级维护也很困难（改动任何一点地方都要升级整个系统）

* 系统性能提升艰难，可用性低，不稳定

### 分布式的好处

* 增大系统容量

* 加强系统可用. 之前的模式挂了就都挂了, 分布式挂了之后是一个模块, 不影响整体体验, 可以做兜底.
* 因为模块化，所以系统模块重用度更高

* 因为软件服务模块被拆分，开发和发布速度可以并行而变得更快

* 系统扩展性更高

* 团队协作流程也会得到改善

* 技术升级

### 分布式和单体结构的对比

|                | 传统单体架构                                                 | 分布式架构                         |
| -------------- | ------------------------------------------------------------ | ---------------------------------- |
| 新人的学习成本 | 业务逻辑成本高                                               | 架构逻辑成本高                     |
| 部署、运维     | 容易                                                         | 发布频繁，发布顺序复杂、运维难     |
| 隔离性         | 一损俱损，殃及鱼池                                           | 故障影响范围小                     |
| 架构设计       | 难度低                                                       | 难度指数级上升                     |
| 系统性能       | 响应快<br />(都是本地调用, 不需要服务之间调用, 节省网络请求的成本)<br />吞吐量小 | 响应慢、<br />呑吐量大             |
| 测试成本       | 低                                                           | 很高(都分成了多个模块, 日志也分散) |
| 技术多样性     | 技术单一且封闭                                               | 技术多样且开放                     |
| 系统扩展性     | 扩展性差                                                     | 扩展性很好                         |
| 系统管理成本   | 成本低                                                       | 成本高(时间同步, 数据同步)         |

## CAP定理

CAP的重要性

CAP是什么 -> 分区容错(P), 一致性(C), 可用性(A)

CAP如何选择 -> 选择的规则

---

### CAP的重要性

不可能同时满足CAP全部三个, 最多满足两个. 

网络传输出问题时的对策和解决方案, 如何在出现网络故障时维持系统的正常运转, 结合CAP理论进行权衡

### CAP是什么

C(Consistency，一致性): 读操作是否总能读到前一个写操作的结果. 数据改变需要被感知到

A(Availability，可用性): 非故障节点应该在合理的时间内作出合理的响应

P(Partition tolerance,分区容错性): 当出现网络分区现象后，系统能够继续运行. 理解成网络错误. 我这边有内容, 因为通讯断了读取不到内容.

<img src="img/分布式和微服务/image-20220108093552330.png" alt="image-20220108093552330" style="zoom:50%;" />

不存在三个都存在的层次.

#### Partition tolerance分区容错性

分区容错

结点之间网络通讯失败. 

<img src="img/分布式和微服务/image-20220108095632062.png" alt="image-20220108095632062" style="zoom:67%;" />

一个在中国, 一个在美国, 传输不稳定, 发生错误后G1发送消息给G2就无法接收 -> 分区容错

一般分区容错是无法避免的. 一般一定存在. -> 又无法同时三个都保证, 所以CP或者AP

#### Consistency 一致性

内容被改变后, 后续能否被感知

<img src="img/分布式和微服务/image-20220108100017018.png" alt="image-20220108100017018" style="zoom:80%;" />

![image-20220108100025766](img/分布式和微服务/image-20220108100025766.png)

G1和G2没有达到一致性, client会读取到不同的内容

<img src="img/分布式和微服务/image-20220108100110295.png" alt="image-20220108100110295" style="zoom:67%;" />

从不同地方读取数据是一致的

#### Availability 可用性

可用性: 非故障节点应该在**合理的时间**内作出合理的响应(不是错误或超时的响应), 但是可能**不是最新的数据**

可用的, 只是没有一致性

#### CAP如何选择

举例:

* 火车票

保证一致性, 否则 -> 同一个车次的同一个座位

必须保证一致性

* 银行转账

重点是钱的数目要正确, 数据绝对可靠, 可以有延迟, 但是不能出错

---

P是一定的, CP或者AP

* 可用性高于一致性的场合: 

CDN, 不同地点之间的缓存同步不强调一致性, 用户拿到新老版本的网页影响不大, 优先保证可用性, 一致性后续慢慢同步过去. 优先保证无论何时何地访问网页都可以看到

* 一致性高于可用性的场合: 

支付场合, 可以允许暂时的不可用, 但是绝对不能不一致. 

综上, 根据业务场景选择CAP. 

## 集群, 分布式, 微服务

### 集群和分布式的区别

分布式：一个业务**分拆多个子业务**, 部署在不同的服务器上. 多台机器之间进行通信, 协同工作完成业务.

集群：**同一个**业务, 部署在多个服务器上. 依然是一个单体服务, 只是部署到了多个机器, 变成了集群, 每个集群内容一致, 对外用负载均衡进行调度.

### 集群和微服务的区别

集群: 分散**压力**. 集群是把压力通过复制机器的方式分散出去. 

微服务: 分散**能力**. 把各个模块拆分, 这个服务负责这个模块, 那个服务服务负责那个模块. 

### 分布式和微服务的区别

微服务是一种结构设计方式, 大的服务拆成一个个小的服务, 每个服务只对应一个功能, 做一件事, 可以独立部署, 服务之间通过通讯进行调用, 每个服务独立开发测试.

分布式强调的是部署的方式, 

微服务是**架构设计**方式, 从逻辑角度对系统进行拆分

分布式是**系统部署**方式, 机器与机器之间遇到的通讯问题, 时间不一致, 协调, 容错. 实际的部署的物理机构

在做设计的时候, 先做逻辑架构(微服务)再做实际物理架构(分布式)

# 微服务

## 什么是微服务

### 微服务和单体服务

单体服务:

<img src="img/分布式和微服务/image-20220108112925854.png" alt="image-20220108112925854" style="zoom:67%;" />

* 部署效率低下. 代码, 依赖越来越多. 编译打包部署时间很长. 线上发布, 服务启动时间很长. 一般又灰度发布, 每次上线时间太长.
* 团队写作开发成本过高. 
* 系统可用性差. 所有功能在同一个包, 系统跑在一个进程内, 一个功能出现问题, 整个都会出现问题.

---

针对这些问题, 提出了服务化的思想:

* 把传统的单机应用中的本地方法调用, 改造成通过**RPC, HTTP产生的远程方法调用**.

* 把模块从单体应用中拆分出来, 独立成一个服务部署 -> 代码复用, 业务理解, 解耦

* 例如: 用户模块就可以独立开发, 测试, 上线和运维, 可以交由专门的团队来做, **与主模块不耦合**

![image-20220108113539590](img/分布式和微服务/image-20220108113539590.png)

请求走到网关进行转发, 微服务中一个一个独立模块, 对外通过api提供服务

---

微服务:

* 一种架构风格

* 开发单个应用作为一系列**小型服务**(用户模块, 订单模块等)的套件, 其中每个服务都运行在**自己的进程**中, 并且通过**轻量级的机制**实现彼此间的通信, 这通常是**HTTP**资源API

* 这些服务是围绕着业务功能构建的, 并且可以通过完全**自动化的部署**机制进行独立部署

* 这些服务的集中式管理做到了最小化(例如docker相关技术), 每一种服务都可以通过**不同的编程语言**进行编写, 并且可以使用**不同的数据存储技术**

### 微服务的特点

* 组件以**服务**形式来提供. 微服务是面向服务的, 以独立部署的服务来作为一个个组件, 而不是提供类库和方法之间的本地调用. 需要明确服务之间的接口和协议
* 微服务是产品不是项目. 对产品的整个生命周期负责, 
* 轻量级通信, 独立进程. 更倾向于RESTful, rpc, http. 轻量级的消息队列, rabbitMQ. 
* **分散**治理, 去中心化治理. 责任下放, 需要告警等监控
* **容错性**设计. 每个服务独立, 对每个模块需要有日常的故障检测, 某个模块出错会导致其他模块
* 团队组织架构的调整

<img src="img/分布式和微服务/image-20220108115522872.png" alt="image-20220108115522872" style="zoom:67%;" />

### 微服务的优缺点

优点:

* 服务简单, 便于学习和上手, 相对易于维护. 一开始模块少
* 独立部署, **灵活**扩展

<img src="img/分布式和微服务/image-20220108115933505.png" alt="image-20220108115933505" style="zoom:67%;" />

* 技术栈丰富. 可以实验新技术, 从边缘模块开始

缺点:

* 运维成本过高

* 接口可能不匹配. 

* 代码可能重复
* 架构复杂度提高. 每一个模块的复杂度降低, 但是整体架构更复杂了

---

<img src="img/分布式和微服务/image-20220108120220187.png" alt="image-20220108120220187" style="zoom:67%;" />



### 微服务的两个门派

#### Spring Cloud和Dubbo

* Spring Cloud: 众多子项目. 成熟的微服务框架系列. 不仅是某一个模块, 而是整个微服务提供解决方案. 众多的子项目: 网关, 配置中心, 服务注册, 服务发现, 智能路由, 全局锁等
* dubbo: 高性能, 轻量级的开源Java RPC框架, 它提供了三大核心能力: 
  * 面向接口的远程方法调用
  * 智能容错和负载均衡
  * 服务自动注册和发现

可以看到, dubbo提供的能力是Spring Cloud的一个子集

#### 整体对比

| 核心组件     | Dubbo     | Spring Cloud                 |
| ------------ | --------- | ---------------------------- |
| 服务注册中心 | Zookeeper | Spring Cloud Netflix Eureka  |
| 服务调用方式 | RPC       | REST API                     |
| 服务网关     | 无        | Spring Cloud Netflix Zuul    |
| 断路器       | 不完善    | Spring Cloud Netflix Hystrix |
| 分布式配置   | 无        | Spring Cloud Config          |
| 服务跟踪     | 无        | Spring Cloud Sleuth          |
| 消息总线     | 无        | Spring Cloud Bus             |
| 数据流       | 无        | Spring Cloud Stream          |
| 批量任务     | 无        | Spring Cloud Task            |

无: 并不是无法实现, 只是dubbo不提供, dubbo可以和其他的框架组件进行整合. 例如:Config可以使用百度的disconf, 淘宝的diamond来实现. 服务跟踪可以使用京东的Hydra. 批量任务可以使用当当Elastic-Job

#### 通信协议对比

dubbo: RPC

Spring Cloud: REST(http协议)



* RPC: 整体效率高, 传输同样体量的内容, 网络传输内容更小速度更快. 

* RPC缺点:
  * 服务提供方和消费方依赖方式太强. dubbo RPC不是通用的协议, 需要找到对应的依赖, 代码级别的强依赖. REST类似一纸契约, 不存在强依赖, 也是因为不存在代码级别的强依赖, 可能定义的内容和实际提供的内容不一致
  * dubbo对平台(语言)敏感, 难以简单复用. 如果要对外提供服务, 需要额外实现一层代理, 把RPC接口转换成http才可以对外发布. Spring Cloud本身已经对外提供服务, 更好的复用性

#### 文档质量

Dubbo的文档提供了中文与英文两种版本, 细致

Spring Cloud文档体量大, 更多的是偏向整合, 更深入的使用方法还是需要查看其整合组件的详细文档


#### 选型建议

dubbo阿里系, 中间停止更新了一段时间.

Spring Cloud类似品牌机, 稳定可靠

Dubbo类似组装机, 自由度高, 但是需要自己承担兼容性测试. 

自身的研发水平和所处阶段

## 微服务拆分

### 拆分的时机

第一阶段的主要目标是快速开发和验证想法, 验证产品是否可行. 此时功能设计不用太复杂. 一开始功能都在一起, 做集中的开发测试运维, 高效成本低, 如果通过就进行下一步的迭代. 

进一步增加更多的新特性来吸引更多的目标用户

同时进行开发的人员超过10人, 这个时候就该考虑进行服务化拆分了

应用越来越庞大了之后, 就要考虑拆分了

### 不适合拆分的情况

* 小团队, 创业初期, 快速做出雏形. 技术基础薄弱

* 流量不高, 压力小, 业务变化也不大. 场景: 企业内部管理系统

* 对延迟很敏感的低延迟高并发系统. 微服务通信的时延比单体的高, 因为网络通信调用

### 拆分的方法

#### 纵向拆分

按照业务维度拆分, 关联程度紧密的就拆分成一个微服务.

社交app: 评论一个微服务, 消息通知一个微服务, 个人主页一个微服务

#### 横向拆分

按照公共领域拆分.

社交app的服务都要用到用户这个模块, 纵向拆分的时候每个都要实现自己的用户功能, 成本高. 所以把用户服务横向拆分出来, 功能提供给各个模块, 复用用户服务

---

两者根据业务综合分析, 可以结合使用. 

### 微服务扩展

<img src="img/分布式和微服务/image-20220108140514398.png" alt="image-20220108140514398" style="zoom:50%;" />

x轴: 水平复制. 单体应用最典型的扩展方式, 把整个系统作为整体, 多部署几套, 前面加上负载均衡即可. -> 水平复制效果不是很好, 存在资源浪费 -> y轴, 功能解耦

y轴: 功能解耦. 微服务拆解, 

z轴: 数据分区. 数据库拆分. 例如: VIP用户单独拆出来一个库. 按照手机尾号拆分数据库

---

自动按需扩展

* 根据CPU负载程度, 特定时间(比如周末), 消息中间件的队列长度, 业务具体规则, 预测等来决定是否扩展. 对各个维度做评判, 达到阈值时, 自动扩展

* 自动分配一个新的服务实例, 提高可用性

* 提高了可伸缩性(双11之后, 自动减少服务器)

* 具有最佳使用率, 节约成本

## 微服务重要模块

以一次基本的服务调用为例. Consumer调用Provider的时候, 需要经历的步骤: 

provider描述服务. 是http服务还是其他类型的服务, 如果是http服务, 接口是什么样子, 返回的内容.

provider注册中心注册服务. 暴露给consumer

服务框架. 统一工作. 协议是TCP, UDP还是http. 传输方式: 同步异步, 单链接or多路复用. 数据是否需要压缩, 压缩格式. 提高网络利用率. json序列化还是java对象序列化

复杂均衡. 多个provider时

熔断与降级. 保险措施, 虽然某个模块无法提供服务, 但是有兜底策略

网关. 服务多了之后, 用户不可能每个请求打到不同的地址, 用户也不知道地址是什么. 提供统一的网关给用户, 用户都打到网关, 由网关做下一步的分发. 同时网关还可以做到统一转换, 权限校验, 过滤器.

## 案例: 新零售业务商品中心微服务化过程

### 背景

业务方: 

* 用户: app, 手淘导流, 线下pos

* 运营: Web
* 一线工作人员: 履约终端app, 拣货终端(扫码枪)

业务需求: 每个模块后面都拆成了N个微服务

* 商品模块
* 订单中心. 和支付中心连接
* 履约中心. 后续发货工作
* 库存模块. 需要预防超买超卖问题
* 用户中心. 穿插在整个链路中
* 搜索模块. 
* 后台运营系统.  -> 设置营销模块等
* 营销模块
* 导购投放系统
* 购物车模块

以商品模块的迭代为例:

### 商品模块迭代

#### 初代版本

<img src="img/分布式和微服务/image-20220108144323926.png" alt="image-20220108144323926" style="zoom:67%;" />

所有功能都在一个war包下. 单体应用

#### 改造 - 抗压维度划分

根据抗压维度来划分, 把高频(qps很高)的服务拎出来, 这部分服务压力大, 把这部分服务和基础服务隔离开来.

---

商品发布服务和库存发布服务: 

低频瞬时流量场景. 3W+ QPS. 

商品发布: 开了新门店, 10w多商品一键发布到新店上, 短时间打很高的qps. 

库存发布: 每天半夜发布第二天的库存, 后台执行的批量请求, 在天中的某个时间段触发. 影响到的商品数量很多.

将这两个模块隔离出来, 即使因为突发流量导致不可用, 也不会影响其他服务. 

---

商品详情页和商品搜索服务: 

高频匀速流量场景. 高频: 在用户下单前, 会不停查看商品详情

---

一些低频场景: 商品编辑. 预售, 改价单. 营销规则设置(买二送一等活动). 优惠券模板. 商品类目编辑. 各种运营场景

#### 改造 - 业务维度

* 定时任务场景: 改价单. 库存发布计划

* 主链路+用户场景: 商品详情页. 商品搜索服务. (以上两个是主链路核心模块). 广告投放. 营销优惠计算, 领优惠券(必须参与订单价格计算). 购物车/订单页商品信息.
  * 主链路需要投放更多的硬件资源, 配置细致的降级和熔断策略.

* 运营场景: 商品编辑. 预售商品设置. 营销规则设置. 优惠券模板. 商品发布服务. 商品类目编辑.

#### 改造 - 指导方针

* 隔离业务场景. -> 尽可能剥离主链路场景.(重要模块, 用户下单的主要步骤, 需要更多资源守护, 不能被其他边缘业务影响)

* 剥离高频访问接口. => 高qps容易被高流量冲垮, 需要减轻此服务对其他服务的影响

#### 修改后

<img src="img/分布式和微服务/image-20220108151639196.png" alt="image-20220108151639196" style="zoom: 67%;" />

UMP: 营销优惠中心

* 淘系中台为所有的事业部业务方提供技术支持(IC订单, 淘系商品, UMP, 支付系统)

* 商品中心拆解两个服务: 商品详情页微服务(高频高并发)和商品发布微服务(低频, 有突发流量). 
  * 需要对接上各种中间件: 分布式配置中心, 缓存, 图片存储视频存储. 
  * 因为商品发布链路长有可能出错误. 引入容错机制做异常补偿. 失败请求转发到RocketMQ中然后重新消费.

* 服务淘宝微服务. 专门对接淘系中台. 
  * 当然服务淘宝微服也可能成为瓶颈. 所以也可以直接把详情页微服务和商品发布微服务直接对接到淘系中台

* 商品资源位微服务. 设置手机app的展示商品列表顺序布局
* 商品后台批量任务: 改价单和库存发布. 定时任务, 对接到RocketMQ做流量削峰, 降低突发流量对系统的冲击
* 商品搜索微服务. 重要的微服务, 提供手机app端搜索. 
  * 运营在后台也需要搜索, 走另外的链路: OpenSearch框架提供搜索支持

























